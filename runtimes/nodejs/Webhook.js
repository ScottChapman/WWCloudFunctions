/*
 * This is a Webhook End-point for Watson Workspace. You will need to modify the credentials below
 * to contain the actual credentials for your Watson Workspace App.
 *
 * This action will perform all the necesary validation and hand-shaking to Watson Work Services.
 * Actual events will be published on the EventTrigger trigger
 * The following package parameters are used:
 * WWAppId - The Watson Workspace appId
 * WWAppSecret - The Watson Workspace App AppSecret
 * WWWebhookSecret - The Watson Workspace Webhook Secret
 * WWEventTopic - The name of the topic to send events to
 */

var crypto = require("crypto");
var openwhisk = require("openwhisk");
var util = require("util");
var _ = require("lodash");
var mustache = require("mustache");
var annotationGQL = {
    GraphQLExpansion: `
   query {
     message(id: "{{messageId}}") {
       content
       id
       created
       createdBy {
         displayName
         id
         emailAddresses
         photoUrl
       }
     }
   }`
};

var expansion = {
    "message-annotation-added": annotationGQL,
    "message-annotation-edited": annotationGQL,
    "message-annotation-removed": annotationGQL,
};

function samePackage(action) {
  return (process.env.__OW_ACTION_NAME.replace(/\/[^\/]+$/,"") + "/" + action).replace(/^\/[^\/]+\//,"");
}

function expandEvent(body, params, ow) {
    return new Promise((resolve, reject) => {
        // Check to see if there is an expansion GraphQL expression to run
        if (body.hasOwnProperty("type") && expansion.hasOwnProperty(body.type)) {
            var exp = expansion[body.type];
            ow.actions.invoke({
              name: samePackage("GraphQL"),
              blocking: true,
              params: {
                  string: mustache.render(exp.GraphQLExpansion, body)
              }
            }).then(resp => {
              // If annotation, mark it as generated by my app if it was
              /* istanbul ignore else  */
              if (body.type.startsWith("message-annotation"))
                body.appEvent = resp.response.result.data.message.createdBy.id === params.AppId;

              resolve(_.merge(body, resp.response.result.data));
            }).catch(err => {
              reject(err);
            });
        } else {
            resolve(body);
        }
    });
}

function cleanUpEvent(event, params) {
    // expand annotationPayload into JSON obejct if it exists.
    if (event.hasOwnProperty("annotationPayload") && typeof event.annotationPayload === "string")
        event.annotationPayload = JSON.parse(event.annotationPayload);

    // Was this event generated by my app?
    if (_.get(event,"annotationPayload.targetAppId"))
        event.appEvent = event.annotationPayload.targetAppId === params.AppId;
    else
        event.appEvent = event.userId === params.AppId;

    // Cleanup time field
    /* istanbul ignore else  */
    if (event.hasOwnProperty("time"))
        event.time = Date(event.time).toString();
}

function closeAction(annotation, params, ow) {
  var card = {
    type: 'INFORMATION',
    title: 'Action Completed',
    text: "You can close this action.",
    buttons: []
  };

  /* istanbul ignore else  */
  if (_.has(annotation,"annotationPayload.actionId.response")) {
    _.merge(card, annotation.annotationPayload.actionId.response);
  }

  ow.actions.invoke ({
    name: samePackage("TargetedMessage"),
    params: {cards: card, annotation: annotation}
  });
}

function main(params) {
    return new Promise((resolve, reject) => {
        var ow = openwhisk(
            _.get(params,"WatsonWorkspace.OWArgs",{})
        );
        var rawBody =Buffer.from(params.__ow_body, "base64").toString();
        var req = {
            rawBody: rawBody,
            body: JSON.parse(rawBody),
            headers: params.__ow_headers
        };

        // separate Workspace paramaters
        var workspaceParams = params.WatsonWorkspace;
        _.omit(params,"WatsonWorkspace");

        if (!validateSender(params, req)) {
            reject({
                statusCode: 401,
                body: "Invalid Request Signature"
            });
        }
        if (_.get(req.body, "type") === "verification") {
            var body = {
                response: req.body.challenge
            };
            var strBody = JSON.stringify(body);
            var validationToken = crypto.createHmac("sha256", workspaceParams.WebhookSecret).update(strBody).digest("hex");
            resolve({
                statusCode: 200,
                headers: {
                    "Content-Type": "text/plain; charset=utf-8",
                    "X-OUTBOUND-TOKEN": validationToken
                },
                body: strBody
            });
        } else {

            // Clean up the event
            cleanUpEvent(req.body,workspaceParams);

            if (_.get(req.body, "annotationType") === "actionSelected" && req.body.appEvent) {
                var triggerName = "WWActionSelected";
                var prefix = "BUTTON_SELECTED: ";
                if (req.body.annotationPayload.actionId.startsWith(prefix)) {
                    triggerName = "WWButtonSelected";
                    var action = req.body.annotationPayload.actionId.substr(prefix.length)
                    try {
                        req.body.annotationPayload.actionId = JSON.parse(action);
                    }
                    catch (err) {
                        req.body.annotationPayload.actionId = action;
                    }
                    closeAction(req.body, params.workspaceParams,ow);
                }
                // Send event to topic
                ow.triggers.invoke({
                    name: triggerName,
                    params: req.body
                }).then(result => {
                    resolve({
                        statusCode: 200,
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: {
                            status: "OK!"
                        }
                    });
                }).catch(/* istanbul ignore next */err => {
                    reject({
                        statusCode: 401,
                        message: "Error firing trigger",
                        error: err
                    });
                });
            }
            else {
                // Expand Event
                expandEvent(req.body, workspaceParams, ow).then(body => {

                    // Send event to topic
                    ow.triggers.invoke({
                        name: body.appEvent ? "WWApplicationEvents" : "WWWebhookEvents",
                        params: body
                    }).then(result => {
                        resolve({
                            statusCode: 200,
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: {
                                status: "OK!"
                            }
                        });
                    }).catch(/* istanbul ignore next */err => {
                        reject({
                          statusCode: 401,
                          message: "Error firing trigger",
                          error: err
                        });
                    });
                }).catch(/* istanbul ignore next */err => {
                    reject({
                      statusCode: 401,
                      message: "Error expanding event",
                      error: err
                    });
                });
            }
        }
    });
}


function validateSender(params, req) {
    var ob_token = req.headers["x-outbound-token"];
    var calculated = crypto.createHmac("sha256", params.WatsonWorkspace.WebhookSecret).update(req.rawBody).digest("hex");
    return ob_token == calculated;
}

exports.main = main;
exports.setOpenwhisk = function(obj) {
  openwhisk = obj;
}
